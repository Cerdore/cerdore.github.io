[ { "title": "2PC加强版--Percolator", "url": "/posts/make2pcstronger_percolator/", "categories": "技术, 数据事务", "tags": "2PC, 分布式事务, 一致性, 数据库", "date": "2022-05-05 14:51:14 +0000", "snippet": "Reference[1]. https://zhuanlan.zhihu.com/p/53197633[2].[TOC]2PC问题：如何保证多节点对某件事情的原子性难点：节点可能宕机、网络可能分区、请求可能超时方案： 2PC。Prepare + commit 两个阶段缺点： 同步阻塞：协调者(Coordinator)宕机，Worker节点不清楚该怎么办了，事务可能会block 延时高：需要持久化 decision logPercolator动机：为BigTable提供跨行跨表的事务原子性，同时解决 2PC 的同步阻塞问题。方案：结合共识（Consensus）和 2PC 算法，将decision log 高可用，其他的信息也会保存primary key的decision log，有一台机器宕机没有影响。缺点： 延时高：decision log不仅需要持久化，还需要达成共识【补充图片。】隔离级别：SI 快照隔离级别SI隔离级别的问题：两个都有读A读B的事务，事务1中间set a=b, 事务2中间set b = a，最后可能会导致a和b交换。可能无法保证可串行化。 对于读：读操作都能够从一个带时间戳的稳定快照获取 对于写：较好地处理写-写冲突：若事务并发更新同一个记录，最多只有一个会提交成功全局时钟： tidb通过pd获取全局时钟。时钟 TSO并发控制：MVCC，读写不互相阻塞。读事务可以无锁快照读。就是存储开销大。实现预备概念Primary Key：有个事务要写一批key，任意选一个key当这个事务的主键，通过这个主键判断事务状态（commit， rollback）。PreWriteCommitstateless cooordinator：clientlazy方式的锁清理Percolator 存储布局Percolator在BigTable上抽象了五个COLUMN，其中三个跟事务相关。Data Column CF_DEFAULT 存储值{key, start_ts} -&amp;gt; valueLock Column CF_LOCK: 存储事务的锁信息tinysql中：{key -&amp;gt; lock_info}论文中：{key, start_ts} -&amp;gt; {primary_key, lock_type, …}primary_key: 事务primary引用。在执行Percolate事务时，会从待修改的keys中选择一个(随机选择)作为 Primary，其余的则作为 Secondaries.prewrite阶段和data column一起写入。事务产生的锁，未提交的事务会写本项，记录primary lock的位置。事务成功提交后，该记录会被清理。Write Column CF_WRITE 已提交的数据信息。存储提交时间和类型{key, commit_ts} -&amp;gt; start_ts{key, commit_ts} -&amp;gt; wrIte_info判断本次事务是否提交成功。只有该列正确写入后，事务的修改才会真正被其他事务可见。读请求会首先在该COLUMN中寻找最新一次提交的start timestamp，这决定了接下来从DATA COLUMN的哪个key读取最新数据。工作流程 通过 tso，给一个事务分配一个start timestamp 预写这个事务的所有 key。写入到kv存储里加锁 分配一个 commit timestamp。 提交 primary keys。根据主键的情况进行判断，如果主键提交成功，secondary keys 可以进行异步提交。 根据提交状态决定是否回滚PreWrite 客户端获取全局唯一时间戳作为当前事务的 start_ts； 客户端会从所有key中选出一个作为 Primary，其余的作为 Secondaries。并将所有的key/value数据写入请求并行地发往对应的存储节点。存储节点对key的处理如下： 写-写 冲突检查：从WRITE COLUMN列中获取当前key的最新数据，若其 commit_ts 大于等于 start_ts，说明在该事务的更新过程中其他事务提交过对该key的修改，返回WriteConflict错误 检查key是否已被锁，如果是，返回KeyIsLock的错误 向LOCK COLUMN列写入 {start_ts, key, primary_ref}为当前key加锁。若当前key被选为primary， primary_ref 标记为 Primary 。若为 Secondary，则指向 primary 的信息 向DATA COLUMN列写入数据 {key, start_ts, value} Commit 从Oracle获取时间戳作为事务的提交时间 commit_ts 向primary key所在的存储节点发送commit请求 步骤2正确完成后该事务即可标记为成功，接下来异步并行地向secondary keys所在的节点发送commit请求 存储节点对于客户端请求的处理： \\1. 获取key的lock,检查其合法性，若非法，则返回失败 \\2. 将 {key, commit_ts, start_ts}写入WRITE COLUMN \\3. 从LOCK COLUMN中删除key的锁记录以释放锁值得说明的是，一旦 Primary 节点提交成功后，整个事务就算提交成功了。在某些实现中（如TiDB），Commit阶段并非并行执行，而是先向 Primary 节点发起commit请求，成功后即可响应客户端成功且后台异步地再向 Secondaries 发起commit。读取数据读取数据时，需要从 WRITE COLUMN 中寻找有无读取的key。寻找一个最新的start_ts，然后通过 {key + start_ts}在DATA COLUMN中找到value。锁的处理TODO" }, { "title": "计算机网络总结", "url": "/posts/computernetwork/", "categories": "技术", "tags": "计算机网络", "date": "2022-04-14 08:01:58 +0000", "snippet": "" }, { "title": "操作系统总结", "url": "/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/", "categories": "TOP_CATEGORIE, SUB_CATEGORIE", "tags": "操作系统", "date": "2017-07-01 00:00:00 +0000", "snippet": "操作系统虚拟化虚拟化面对的两个挑战 不增加系统开销的情况下实现虚拟化。 操作系统需要控制权，那在保持控制权的情况下实现虚拟化就是另一个挑战。 执行系统调用的过程 执行 trap 指令，跳入内核，并且将特权级别提升至内核模式。然后调用进程执行所需的工作。完成后，调用一个 return-from-trap 返回到发起调用的用户程序，降低特权级别，回到用户模式。 为什么会有中断？ 首先这里的背景是多个任务时分共享 CPU，操作系统需要进行资源管理。所以系统内核需要有控制权来管理多个进程，防止出现单个进程一直执行或者访问没有权限的资源。 软中断和硬中断？ 内存管理进程与线程" }, { "title": "Test", "url": "/posts/test/", "categories": "", "tags": "", "date": "2017-02-22 00:00:00 +0000", "snippet": "Hello 树先生" } ]
